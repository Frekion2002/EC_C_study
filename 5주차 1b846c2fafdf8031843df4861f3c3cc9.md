# 5주차

내용: 구조체, 포인터심화

## 포인터 리뷰

- 포인터란 메모리의 주소값을 가리키는 변수입니다.

<포인터의 기본개념>

![image.png](image.png)

<포인터 기본 예시>

```c
#include <stdio.h>

int main(void) {
    int i = 10;
    int* p;
    p = &i;
    *p = 20; // 포인터를 통해 변수의 값 변경
    printf("i = %d\n", i); // 20이 출력됨
    return 0;
}
```

---

## 포인터의 활용

---

### 이중 포인터

### 이중 포인터란?

- 개념: 포인터 변수를 가르키는 또 다른 포인터 변수
- 즉, 변수의 주소를 저장하는 것이 포인터라면, 이중 포인터는 포인터 변수의 주소를 저장한다.

### 이중 포인터의 선언과 구조

```c
자료형 **이름;
```

- 가장 기본적인 형식

```c
int num = 10;        // 일반 변수
int *ptr = &num;     // 포인터: num의 주소 저장
int **dptr = &ptr;   // 이중 포인터: ptr의 주소 저장
```

- 각 변수 간 선언의 비교

```c
int a = 1, b = 2, c = 3;
int* p1 = NULL, * p2 = NULL;
int** pp1 = NULL, ** pp2 = NULL;
```

- 여러 이중 포인터 동시 선언

<aside>
💡

자 위의 코드에서 p1, p2, pp1, pp2는 NULL인데 출력하면 무슨 값이 출력될까요?

</aside>

```c
int* p1, p2; // p1만 포인터, p2는 일반 int 변수
int **p1, *p2; // p1은 이중 포인터, p2는 단일 포인터
```

- 주의사항!
    - 이런식으로 동시 선언 할때는 에스터리스크를 변수명 앞에 붙여야 한다.
    

<aside>
💡

질문!

int ***ppptr; 

</aside>

- 이런 삼중 포인터도 있을까요??
- 정답
    - 포인터의 포인터의 포인터를 선언할 수 있지만, 실무에서는 이중 포인터까지만 주로 사용한다.

### 메모리 구조 그림

```c
#include <stdio.h>
 
int main(void)
{
    int * ptr;     // 포인터 선언
    int ** dptr;    // 이중 포인터 선언
    int num = 10;
 
    ptr = &num;    // 포인터에 num 주소 대입 
 
    dptr = &ptr;    // 이중 포인터에 ptr 주소 대입
 
    printf("%d\n", **dptr);    // 포인터를 두 번 역참조하여 num의 메모리 주소에 접근
 
    return 0;
}
```

![image.png](image%201.png)

- 변수 num의 주소를 ptr에 저장하고, 변수 ptr의 주소를 dptr에 저장했으므로 다음과 같은 그림을 그릴 수 있다.

![image.png](image%202.png)

- dptr은 ptr의 주소를 가리키고 있고, ptr은 num의 주소를 가르키고 있다.
- 그렇기에 *dptr은 포인터 변수 ptr을, **dptr은 변수 num을 의미하게 된다.

<aside>
📌

ptr을 처음 선언할 때 *은 포인터 형을 나타내고 선언된 ptr에 다시 *을 사용하면 값에 접근한다.!

</aside>

- 가장 기초적이고 원초적인 예시

```c
#include <stdio.h>

int main() {
    int num = 10;
    int *ptr = &num;
    int **dptr = &ptr;

    printf("num의 값: %d\n", num);           // 10
    printf("*ptr의 값: %d\n", *ptr);         // 10
    printf("**dptr의 값: %d\n", **dptr);     // 10
    return 0;
}
```

- 이중 포인터를 통한 값 변경

```c
#include <stdio.h>

int main() {
    int i = 10;
    int *p = &i;
    int **q = &p;
    **q = 30;
    printf("%d\n", i); // 30 출력
    return 0;
}
```

- 문자열 배열에서 이중 포인터 활용

```c
#include <stdio.h>

int main(void) {
    char* p[] = { "C", "C++", "C#", "Java" };
    char** pp = p; // 이중 포인터 선언 및 포인터 배열 참조

    for (int i = 0; i < 4; i++) {
        printf("pp[%d] = %s\n", i,   *(pp + i));
    }
    return 0;
}
```

- 2차원 배열을 이중 포인터로 접근

```c
#include <stdio.h>

int main() {
    int b[4][3] = {
        {11, 12, 13},
        {21, 22, 23},
        {31, 32, 33},
        {41, 42, 43}
    };
    int *p1 = (int *)b; // 2차원 배열을 1차원처럼 포인터로 접근

    for (int i = 0; i < 12; i++) {
        printf("%d ", *(p1 + i)); // b[i/3][i%3]와 동일
    }
    printf("\n");
    return 0;
}
```

- C언어에서 2차원 배열은 행(row)이 먼저, 열(column)이 나중인 “행 우선(row-major)” 방식으로 메모리에 저장된다.
- 즉, 메모리에는 다음과 같이 한 줄로 연속적으로 저장된다.

```c
b[0][0] b[0][1] b[0][2] b[1][0] b[1][1] b[1][2] ... b[3][2]
```

- int *p1 = (int *)b;의 의미
    - b의 이름은 배열의 첫 번째 원소(즉, b의 주소)를 가르킨다.
    - (int *)b로 형변환하면, 2차원 배열의 첫 번째 요소의 주소를 단일 int형 포인터로 해석할 수 있다.
    - 즉, p1은 2차원 배열의 모든 원소를 1차원 배열처럼 연속적으로 접근할 수 있는 포인터가 된다.

```c
메모리(주소 순서)
+----+----+----+----+----+----+----+----+----+----+----+----+
| 11 | 12 | 13 | 21 | 22 | 23 | 31 | 32 | 33 | 41 | 42 | 43 |
+----+----+----+----+----+----+----+----+----+----+----+----+
  0    1    2    3    4    5    6    7    8    9   10   11   <-- (p1+i)
```

<aside>
💡

2차원 배열 이중 포인터로 접근하기

</aside>

- 문제설명
    - 아래와 같이 4행 3열의 2차원 배열이 있다.
    - 이 배열의 모든 값을 이중 포인터(int**)를 사용해서 출력하는 프로그램 작성
        - s.t. 이중 포인터에 2차원 배열의 주소를 대입하고 *(*(p + i) + j) 형태로 값을 출력하시오

```c
#include <stdio.h>

int main() {
    int b[4][3] = {
        {11, 12, 13},
        {21, 22, 23},
        {31, 32, 33},
        {41, 42, 43}
    };
    // 이중 포인터 선언 및 초기화
    int **p;

    // (여기에 이중 포인터를 이용한 출력 코드 작성)

    return 0;
}
```

- 출력 결과

```
11 12 13 
21 22 23 
31 32 33 
41 42 43 
```

- 정답
    
    ```c
    #include <stdio.h>
    
    int main() {
        int b[4][3] = {
            {11, 12, 13},
            {21, 22, 23},
            {31, 32, 33},
            {41, 42, 43}
        };
        int *pb[4];      // 각 행의 시작 주소를 저장하는 포인터 배열
        int **p = pb;    // 이중 포인터 선언 및 초기화
    
        // 각 행의 시작 주소 저장
        for (int i = 0; i < 4; i++) {
            pb[i] = b[i];
        }
    
        // 이중 포인터를 이용한 2차원 배열 접근 및 출력
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 3; j++) {
                printf("%d ", *(*(p + i) + j));
            }
            printf("\n");
        }
    
        return 0;
    }
    
    ```
    
    - int *pb; 는 각 행의 시작 주소를 저장하는 포인터 배열이다.
    - int **p = pb;로 이중 포인터를 선언하고, pb의 주소를 대입한다.
    - 결국  *(*(p + i) + j)는 b[i][j]와 동일한 효과를 가진다.
        
        

### 이중 포인터를 왜 사용할까?

- **포인터 변수 자체를 함수에서 변경하고 싶을 때**
    - 함수에 포인터를 넘기면, 포인터가 가리키는 값은 바꿀 수 있지만, 포인터 자체가 가리키는 대상을 바꾸려면 이중 포인터가 필요하다.
    
    ```c
    void setPointer(int *p) {
        static int temp = 100;
        p = &temp; // p는 함수 내에서만 변경됨
    }
    ```
    
    - 이 경우 p는 함수 내부에서만 바뀌고, main 함수의 포인터는 변하지 않는다.
    - 즉, 포인터 자체를 함수에서 바꾸려면, 포인터의 주소를 함수에 넘겨야 한다.
    
    ```c
    void setPointer(int **pp) {
        static int temp = 100;
        *pp = &temp; // main 함수의 포인터가 가리키는 대상을 변경
    }
    ```
    
    - 이렇게 하면 함수 내부에서 *pp를 통해 main 함수의 포인터가 가르키는 대상을 바꿀 수 있다.
    
    <실제 예시>
    
    ```c
    #include <stdio.h>
    
    void setPointer(int **pp) {
        static int temp = 100;
        *pp = &temp;
    }
    
    int main() {
        int num = 10;
        int *p = &num;
    
        printf("함수 호출 전: *p = %d\n", *p); // 10
        setPointer(&p);
        printf("함수 호출 후: *p = %d\n", *p); // 100
    
        return 0;
    }
    ```
    
    - setPointer(&p); 에서 p의 주소를 넘긴다.
    - 함수 안에서 *pp = &temp;로 p가 가르키는 주소 자체를 바꾼다.
    - 결과적으로 main 함수의 p가 temp를 가르키게 되어, *p의 값이 100으로 바뀐다.

- **동적 2차원 배열 생성 등 고급 자료구조 구현**
    - 동적할당은 컴퓨터 프로그래밍에서 실행 시간 동안 사용할 메모리 공간을 할당하는 것
    - 이는 실행하는 순간 프로그램이 사용할 메모리의 크기를 고려하여 메모리의 할당이 이루어지는 정적 메모리 할당과는 대조적이다.
    
    - 좀 어려울지도?
        - 운영체제는 이런 프로그램이 실행되면 스택, 코드, 데이터, 힙 영역의 메모리 주소를 할당해주는데 이때, 힙이 동적 메모리에 해당하게 된다.
        - 즉, 실행 시간에 크기가 결정되는 동적 배열 및 리스트와 같은 경우는 힙을 사용하는 것이 보다 공간을 효율적으로 사용할 수 있음.
        - 그러나 C언어의 경우 명시적으로 사용한 공간을 반환해야 함
        - 그렇지 않으면 메모리 누수 ㅠㅠ
    
    - 장점 - 상황에 따라 원하는 크기만큼의 메모리가 할당되고 이미 할당된 메모리라도 언제든 크기 조정 가능
    - 단점 - 더 이상 사용하지 않을 때 명시적으로 메모리를 해제해 주어야 한다.
    
    ![image.png](image%203.png)
    
    ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include <stdio.h>
    #include <stdlib.h>  // malloc, free 함수가 선언된 헤더 파일
    
    int main() {
        int value;
    
    	scanf("%d", &value);
    
    	int* numPtr = malloc(sizeof(int) * value);
    	// (int 크기 * 입력받은 크기)만큼 동적 메모리를 할당
    
    	for (int i = 0; i < value; i++) {
    		numPtr[i] = i;
    	}
    
    	for (int i = 0; i < value; i++) {
    		printf("%d ", numPtr[i]);
    	}
    
    	free(numPtr);  // 동적할당 메모리 해제
    
    	return 0;
    }
    
    ```
    
    - 코드를 뜯어보자!
    
    ```c
    scanf("%d", &value);
    
    int* numPtr = malloc(sizeof(int) * value);
    // (int 크기 * 입력받은 크기)만큼 동적 메모리를 할당 b 
    ```
    
    - value에 값을 입력받아 저장한 후 포인터 변수 numPtr에 int크기에 입력받은 크기를 곱하여 메모리를 할당한다
    - numPtr에는 할당된 메모리의 주소를 담는다
    
    ```c
    for (int i = 0; i < value; i++) {
    		numPtr[i] = i;
    	}
    
    for (int i = 0; i < value; i++) {
    	printf("%d ", numPtr[i]);
    }
    
    free(numPtr);  // 동적할당 메모리 해제
    ```
    
    - 반복문으로 값을 입력받은 후 입력받은 값을 출력하는 반복문이다.
    - **포인터는 배열처럼 사용할 수 있다.**
    - 배열과 마찬가지로 값을 할당하거나 출력할 때 []를 사용하여 인덱스로 접근한다.
    - 마지막으로 동적할당 메모리는 해제하는 free함수를 사용하여 자원을 반환한다.
    
    <aside>
    💡
    
    실습 예제: 동적 메모리 할당을 이용한 정수 배열 입력 및 합계 구하기
    
    1. 사용자에게 저장할 정수의 개수를 입력받으세요.
    2. 입력받은 개수만큼 동적으로 int형 배열을 할당하세요.
    3. 각 배열에 정수를 입력받으세요.
    4. 입력된 모든 정수의 합을 출력하세요.
    5. 프로그램 종료 전 동적으로 할당한 메모리를 반드시 해제하세요.
    </aside>
    
    - 정답
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        int main() {
            int count, sum = 0;
            int* p = NULL;
        
            printf("저장할 정수의 개수를 입력하세요: ");
            scanf_s("%d", &count);
        
            p = (int*)malloc(sizeof(int) * count); // 동적 메모리 할당
        
            if (count > 0) {
                for (int i = 0; i < count; i++) {
                    printf("%d번째 정수 입력: ", i + 1);
                    scanf_s("%d", p + i); // &p[i]와 동일
                }
        
                printf("\n입력된 값 확인: ");
                for (int i = 0; i < count; i++) {
                    printf("%d ", *(p + i));
                    sum += *(p + i);
                }
                printf("\n정수의 합: %d\n", sum);
        
                free(p); // 메모리 해제
            }
        
            return 0;
        }
        
        ```
        
    
    - 2차원 배열
    1. 행 동적 할당
    
    ```c
    arr = (int **)malloc(row * sizeof(int *));
    ```
    
    - arr은 각 행의 시작 주소를 저장하는 포인터 배열이다.
    
    1. 각 행에 열 동적 할당
    
    ```c
    for (int i = 0; i < row; i++) {
        arr[i] = (int *)malloc(col * sizeof(int));
    }
    ```
    
    - 각 행마다 열의 개수만큼 int형 배열을 동적으로 할당한다.
    
    1. 전체 사용 예시
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    int main(void) {
        int row = 3, col = 4;
        int **arr = (int **)malloc(row * sizeof(int *));
        for (int i = 0; i < row; i++) {
            arr[i] = (int *)malloc(col * sizeof(int));
        }
    
        // 값 할당
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                arr[i][j] = i * col + j;
            }
        }
    
        // 값 출력
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                printf("%2d ", arr[i][j]);
            }
            printf("\n");
        }
    
        // 메모리 해제 (할당의 역순)
        for (int i = 0; i < row; i++) {
            free(arr[i]);
        }
        free(arr);
    
        return 0;
    }
    ```
    
    - 주의사항
        - 이중 포인터로 할당된 2차원 배열은 메모리상에서 행별로 따로따로 할당된다(비연속적).
        - 정적 2차원 배열과는 타입과 메모리 구조가 다르므로, 함수 인자 전달 시 주의해야 한다.
    
- **문자열 배열(포인터 배열) 등에서 활용**
    - 위의 예시 참고

- **다중 연결 구조 및 고급 자료구조 구현**
    - 다중 연결 리스트, 트리, 그래프 등 고급 자료구조에서 포인터의 포인터를 사용해 노드의 연결을 동적으로 바꾸거나, 다차원 배열, 테이블 등 복잡한 구조를 다룰 때도 필수적이다.

### 함수에서 이중 포인터 활용 예시

- 문자열 포인터를 함수에서 변경할 때

```c
#include <stdio.h>

void SetMessage(char** pTarget) {
    *pTarget = "인간은 패배하도록 창조된 게 아니야.";
}

int main(void) {
    char* pMsg;
    SetMessage(&pMsg);
    printf("%s\n", pMsg);
    return 0;
}
```

- 함수에서 문자열 포인터의 값을 바꿔야 할 때 이중 포인터를 사용한다.

- 동적 메모리 할당 함수에서 이중 포인터 사용

```c
#include <stdio.h>
#include <stdlib.h>

void allocMemory(int **ptr, int size) {
    *ptr = (int *)malloc(size * sizeof(int));
}

int main() {
    int *arr = NULL;
    allocMemory(&arr, 5);
    for (int i = 0; i < 5; i++) arr[i] = i * 2;
    for (int i = 0; i < 5; i++) printf("%d ", arr[i]);
    free(arr);
    return 0;
}
```

- 함수 내부에서 동적 메모리를 할당하고, 그 주소를 호출자에게 전달할 때 이중 포인터를 사용한다.

- 포인터 배열(문자열 배열) 함수 전달

```c
#include <stdio.h>

void printStrings(char **strs, int n) {
    for (int i = 0; i < n; i++) {
        printf("%s\n", strs[i]);
    }
}

int main() {
    char *words[] = {"apple", "banana", "cherry"};
    printStrings(words, 3);
    return 0;
}
```

- char **strs는 문자열 포인터 배열을 받는 이중 포인터이다.

### 이중 포인터의 핵심 정리

- 개념: 포인터를 가리키는 포인터
- 메모리 구
    - 일반 변수 → 값 저장
    - 포인터 → 변수의 주소 저장
    - 이중 포인터 → 포인터의 주소 저장
    
    ```c
    int i = 10;
    int *p = &i;
    int **q = &p;
    ```
    
    - 여기서 q는 p의 주소를 저장하고, *q는 p를, **q는 i의 값을 가리킨다.
- 간접 참조 - 이중 포인터를 통해 두 번의 역참조(간접 참조)로 실제 데이터를 읽거나 쓸 수 있다.
- 주요 사용 목적
    - 함수에서 포인터 변수 자체(주소)를 변경하고 싶을 때
    - 동적 2차원 배열 등 다차원 구조를 구현할 때
    - 포인터 배열(문자열 배열 등)을 함수 인자로 넘길 때
    - 다차원 배열, 연결 리스트, 트리 등 고급 자료구조 구현에도 활용
    
- 예시

```c
void setPointer(int **pp) {
    static int temp = 100;
    *pp = &temp;
}
// main에서 setPointer(&p); 호출 시 p가 temp를 가리키게 됨
```

### 주의사항

- const문을 활용할 경우 두 눈 크게 뜨고 잘 보세요!
- 변수에서의 const란?
    - 변수를 상수로 만들어주는 역할을 수행하는 구문
        
        ```c
        const int var = 50;  // 변경 불가능! 상수이기 때문에
        ```
        
- 포인터 변수를 대상으로도 const 선언을 할 수 있지만, 변수에서 사용하는 const와는 다른 의미를 갖는다.
    - 포인터에 사용하는 const는 상수로 만드는 선언이 아니다!!
    - **→ 포인터를 통한 변경을 허용하지 않겠다!**
    - 아래의 예시를 보자

```c
#include <stdio.h>
 
int main(void)
{
    int num = 10;
    const int* p = &num;
 
    *p = 20;    // 컴파일 에러
 
    printf("변수 num : %d\n", *p);
 
    return 0;
}
```

- 포인터를 통해서 변수 num 값을 변경하는 것을 허용하지 않는다.

```c
#include <stdio.h>
 
int main(void)
{
    int num = 10;
    const int* p = &num;
 
    num = 20;    // 컴파일 성공
 
    printf("변수 num : %d\n", *p);
 
    return 0;
}
```

- 변수 num은 const로 선언되지 않았기 때문에 언제든지 변경 가능하다.
- 즉, 포인터를 통해 변수 num을 변경하는 것을 막는다.

---

## 구조체

### 구조체란?

- 정의
    - 구조체는 C언어의 기본 타입(int, char 등)을 조합하여 여러 데이터를 하나의 새로운 타입으로 묶는 사용자 정의 자료형이다.
    - 배열이 같은 타입의 집합이라면, 구조체는 서로 다른 타입의 변수들을 하나로 묶는 것이다.
    - 이때 구조체를 구성하는 변수를 구조체 멤버 또는 멤버 변수라고 한다.

```c
struct 구조체이름
{
    멤버변수1의타입 멤버변수1의이름;
    멤버변수2의타입 멤버변수2의이름;
    ...
};
```

```c
struct Book {
    char title[100];
    char author[100];
    int price;
};
```

- 위 예제에서 Book 구조체는 제목, 저자(문자열), 가격(정수) 정보를 한 번에 저장할 수 있다.

### 구조체의 선언과 사용

- 구조체 타입 정의

```c
struct Book {
    char title[30];
    char author[30];
    int price;
};
```

![image.png](image%204.png)

- struct라는 키워드를 통해 구조체의 시작을 알리고, 구조체 이름을 book으로 정의하고 있다.
- 중괄호 사이에 title, author, price와 같은 변수들이 book의 멤버 변수들이다.
- 마지막 세미콜론은 구조체 정의를 종료한다는 의미이다.
- 이런 구조체를 **사용자 정의 자료형**이라고도 한다.

- 구조체 변수 선언

```c
int var;                        // 일반적인 변수
struct Book myBook;             // 구조체 변수
```

- 구조체 변수 선언과 동시에 정의

```c
struct Book {
    char title[100];
    char author[100];
    int price;
} myBook1, myBook2, myBook3;
```

- main함수 안에서 선언

```c
struct Book {
    char title[100];
    char author[100];
    int price;
};

int main(void){
	struct Book myBook1, myBook2, myBook3;
	return 0;
}
```

- typedef로 구조체 별칭 만들기

```c
typedef struct {
    char title[100];
    char author[100];
    int price;
} TEXTBOOK;

TEXTBOOK book1;
```

- typedef를 사용하면 struct 키워드 없이 바로 사용할 수 있다.

### 구조체 멤버 접근 및 초기화

- 멤버 접근
- ‘.’연산자를 사용하여 구조체 멤버 변수에 접근한다.
- 이때 ‘.’은 멤버 연산자 혹은 멤버 접근 연산자라고 부른다.

```c
struct Point {int x; int y;};	

int main(void){
    struct Point P1; // 구조체 변수 P1선언
    P1.x = 3;		// P1의 구조체 멤버 x에 3대입
    P1.y = 4;		// P1의 구조체 멤버 y에 4대입
    return 0;
}
```

- typedef를 사용할 경우의 접근

```c
struct Point{
    int x;		
    int y;		
};	
typedef struct Point Point;	// struct Point 대신에 Point를 사용한다는 의미

int main(void){
    Point P1, P2, P3; // 구조체 변수 P1, P2, P3 선언
    return 0;
}
```

```c
// typedef와 구조체(1)
struct Point{
    int x;		
    int y;		
};	
typedef struct Point Point;	// struct Point 대신에 Point를 사용한다는 의미

// typedef와 구조체(2)
typedef struct Point{
    int x;		
    int y;		
}Point;		// struct Point 대신에 Point를 사용한다는 의미

// typedef와 구조체(3)
typedef struct{
    int x;		
    int y;		
}Point;		// struct Point 대신에 Point를 사용한다는 의미

// typedef와 구조체(4)
struct Point{
    int x;		
    int y;		
}typedef Point;		// struct Point 대신에 Point를 사용한다는 의미
```

- 이 외에도 동일한 표현이 더 있다.

- 문자열

```c
myBook.price = 25000;
strcpy(myBook.title, "C Programming");
strcpy(myBook.author, "홍길동");
```

- 구조체 멤버가 char 배열(문자열)일 경우, 대입 연산자(=)로 값을 할당할 수 없다.
- 반드시 strcpy 함수를 사용해야 한다.

<문자열 전체 예시>

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

typedef struct _p {
	char name[20];
	int x;
	int y;
}Point;

int main(void)
{
	Point p1, p2;

	strcpy(p1.name, "구조체 복사");
	p1.x = 10;
	p1.y = 20;

	// 아래 출력되도록 p2에 p1의 값을 복사해보자.

	strcpy(p2.name, p1.name);
	p2.x = p1.x;
	p2.y = p1.y;

	printf("%s\n", p2.name);
	printf("%d %d\n", p2.x, p2.y);

	return 0;
}
```

- 코드처럼 문자열은 strcpy로, 숫자형은 바로 대입하면 된다.
- 위의 코드를 보면 p2에 p1값을 복사하는 과정이 있는데, 너무 귀찮지 않은가?
- 멤버 변수가 3개여도 귀찮은데 더 많다면?

- p2에 p1값을 복사하는 더 쉬운 방법에 대한 소개

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

typedef struct _p {
	char name[20];
	int x;
	int y;
}Point;

int main(void)
{
	Point p1, p2;

	strcpy(p1.name, "구조체 복사");
	p1.x = 10;
	p1.y = 20;

	// 아래 출력되도록 p2에 p1의 값을 복사해보자.

	memcpy(&p2, &p1, sizeof(Point));

	printf("%s\n", p2.name);
	printf("%d %d\n", p2.x, p2.y);

	return 0;
}
```

- memcpy(복사할 구조체 주소, 원본 구조체 주소, 크기);를 하면 다 복사가 된다.

- 더 편한 방법

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

typedef struct _p {
	char name[20];
	int x;
	int y;
}Point;

int main(void)
{
	Point p1, p2;

	strcpy(p1.name, "구조체 복사");
	p1.x = 10;
	p1.y = 20;

	// 아래 출력되도록 p2에 p1의 값을 복사해보자.

	p2 = p1;

	printf("%s\n", p2.name);
	printf("%d %d\n", p2.x, p2.y);

	return 0;
}
```

- p2=p1; 처럼 그냥 바로 대입해버리면 된다.

<aside>
💡

주의! p2=p1; 처럼 복사할 때, 구조체 멤버에 포인터가 없어야 한다!

</aside>

```c
typedef struct {
    char *name; // 포인터!
    int x;
    int y;
} Point2;

Point2 p1, p2;
p1.name = malloc(20);
strcpy(p1.name, "구조체 복사");
p1.x = 10; p1.y = 20;

p2 = p1; // 포인터 값(주소)만 복사됨
```

- 이 경우 p2.name과 p1.name이 동일한 메모리 주소를 가르키게 된다.
- 즉, 한 쪽에서 name을 바꾸거나 free하면 다른 쪽도 영향을 받거나 심한 오류(이중 free, 메모리 오염 등)가 발생할 수 있다.
- 즉, 구초제 멤버가 모두 값 타입(배열, int, double 등..)이면 p2=p1으로 안전하게 복사할 수 있다.
- 만약 포인터가 있다면 주소만 복사되므로 깊은 복사(deep copy)가 필요할 수 있다.

- 초기화 하는 법

```c
#include <stdio.h>
#include <string.h>

struct Book {
    char title[100];
    char author[100];
    int price;
};

int main() {
		struct Book book2 = {"C언어", "이순신", 30000};
		// 또는 
    struct Book book3 = {.title = "자료구조", .price = 20000};
    printf("title: %s\n", book3.title);   // 자료구조
    printf("author: %s\n", book3.author); // (아무것도 출력되지 않음, 빈 문자열)
    printf("price: %d\n", book3.price);   // 20000

    if (book3.author[0] == '\0') {
        printf("author는 빈 문자열입니다.\n");
    }
    return 0;
}

```

- 이처럼 배열로도 한 번에 초기화 할 수 있는데, book3처럼 author를 초기화 안하면 무슨 값이 들어갈까?
- 결론 - 부분 초기화 시, 지정하지 않은 구조체 멤버는 0(도는 빈 값)으로 자동 초기화 된다.
- chat author;은 빈 문자열이 된다.

### 구조체 배열과 포인터

- 구조체 배열

```c
struct Book library[10];
```

- 여러 개의 구조체 데이터를 배열로 저장할 수 있다.

<좀 더 전체적인 예시>

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

struct point {
    int x;
    int y;
};

int main() {
    
    struct point arr[3] = { {1,2}, {3,4}, {5, 6} };
    int i = 0;

    for (i = 0; i < 3; i++) {
        printf("[%d, %d]\n", arr[i].x, arr[i].y);
    }
    return 0;
}
```

- 이렇게 선언과 동시에 초기화도 가능하다.

- 구조체 포인터
- 구조체 포인터는 구조체 변수를 가르킨다.

```c
struct point pos;
struct point* ptr;
ptr = &pos;

pos.xpos = 1;
pos.ypos = 2;
```

- 구조체 변수 pos를 아래와 같이 접근해서 포인터 변수 ptr을 통해 사용할 수 있다

```c
(*ptr).xpos   // = pos.xpos
(*ptr).ypos   // = pos.ypos
```

- C언어는 접근을 용이하게 하도록 → 연산자를 지원해준다.

```c
ptr -> xpos  // = (*ptr).xpos
ptr -> ypos  // = (*ptr).ypos 
```

<전체적인 예시>

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

struct point {
    int x;
    int y;
};

int main() {
    
    struct point pos;
    struct point* ptr;
    ptr = &pos;

    pos.x = 1;
    pos.y = 2;

    printf("%d %d\n", (*ptr).x, (*ptr).y);
    printf("%d %d\n", ptr->x, ptr->y);
    return 0;
}

```

<좀 더 다양한 예시>

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

struct point {
    int x;
    int y;
};

struct circle {
    double radius;
	struct point* center;
};

int main() {
    
    struct point cen = { 2, 7 };
    double rad = 5.5;

    struct circle ring;
    ring.radius = rad;   
	ring.center = &cen; // ring.center는 cen의 주소를 가리킴

	printf("[%d %d]", ring.center->x, ring.center->y);
    return 0;
}
```

- point형 cen 변수의 주소를 center에 넣어 ring.center를 통해 cen에 접근할 수 있다.
- 실제로 출력 부분을 통해서 cen.x와 cen.y에 ring.center를 통해 접근한 결과를 볼 수 있다.

- 구조체 변수의 주소 값과 첫 번째 멤버의 주소 값은 같다.

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

struct point {
    int x;
    int y;
};

struct circle {
    double radius;
	struct point* center;
};

int main() {
    
    struct point cen;

	printf("%p\n%p", &cen, &cen.x);
    return 0;
}
```

- 결과를 출력해보면 같은 주소값을 가진다는 것을 확인할 수 있다.(배열같네..)

### 구조체와 함수

- 구조체를 함수 인자로 전달
    - 값(복사)로 전달
    
    ```c
    void printBook(struct Book b) {
        printf("%s, %s, %d\n", b.title, b.author, b.price);
    }
    ```
    
    - 구조체가 복사되어 함수에 전달되므로, **함수 내에서 값을 바꿔도 원본에는 영향이 없다**
    
    - 포인터로 전달
    
    ```c
    void setPrice(struct Book *b, int price) {
        b->price = price;
    }
    ```
    
    - 구조체의 주소(포인터)를 전달하면, **함수 내에서 멤버 값을 바꾸면 원본이 바뀐다.**

<함수 예제>

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    char title[100];
    char author[100];
    int price;
} Book;

void printBook(Book b) {
    printf("제목: %s, 저자: %s, 가격: %d원\n", b.title, b.author, b.price);
}

void setPrice(Book *b, int price) {
    b->price = price;
}

int main() {
    Book myBook = {"C언어", "이순신", 30000};
    printBook(myBook);

    setPrice(&myBook, 25000); // 포인터로 전달하여 값 변경
    printBook(myBook);

    return 0;
}

```

### 구조체 활용의 장점

- 복잡한 데이터를 한 번에 관리할 수 있다.
- 함수와 결합해 데이터 처리, 정보 은닉, 코드 가독성 향상에 매우 유용하다.
- 배열, 포인터, 동적할당 등과 결합해 다양한 자료구조(리스트, 트리 등)로 확장 가능하다.

### 실습문제

1. 학생 정보를 저장하고 구조체를 정의하고, 학생 3명의 정보를 입력받아 출력하는 프로그램을 작성해보시오.
- 정답
    
    ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include <stdio.h>
    
    // 학생 정보를 저장하는 구조체 정의
    struct Student {
        char name[50];
        int age;
        float height;
    };
    
    int main() {
        struct Student students[3];
    
        // 학생 3명의 정보 입력 받기
        for (int i = 0; i < 3; i++) {
            printf("학생 %d 이름 입력: ", i + 1);
            scanf("%49s", students[i].name);
            printf("학생 %d 나이 입력: ", i + 1);
            scanf("%d", &students[i].age);
            printf("학생 %d 키 입력 (소수점 포함): ", i + 1);
            scanf("%f", &students[i].height);
        }
    
        // 학생 3명의 정보 출력
        printf("\n입력된 학생 정보:\n");
        for (int i = 0; i < 3; i++) {
            printf("학생 %d: 이름=%s, 나이=%d, 키=%.2f\n", i + 1, students[i].name, students[i].age, students[i].height);
        }
    
        return 0;
    }
    
    ```
    

1. 구조체 포인터를 함수에 전달해 학생의 점수를 변경하는 함수를 만들어보시오.
    1. 학생 이름과 점수는 자유입니다.
- 정답
    
    ```c
    #include <stdio.h>
    
    // 학생 정보를 저장하는 구조체 정의
    struct Student {
        char name[50];
        int score;
    };
    
    // 점수를 변경하는 함수 (구조체 포인터 사용)
    void setScore(struct Student* stu, int newScore) {
        stu->score = newScore;
    }
    
    int main() {
        struct Student s = { "홍길동", 80 };
    
        printf("변경 전: 이름=%s, 점수=%d\n", s.name, s.score);
    
        // 함수 호출로 점수 변경
        setScore(&s, 95);
    
        printf("변경 후: 이름=%s, 점수=%d\n", s.name, s.score);
    
        return 0;
    }
    
    ```